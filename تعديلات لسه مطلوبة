Ø£ÙˆÙ„Ø§Ù‹: Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© Ø§Ù„Ø¹Ø§Ù…Ø© ÙÙŠ Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù

Ø¶Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ø¨Ø¹Ø¯ require('express') Ù…Ø¨Ø§Ø´Ø±Ø© (Ù‚Ø¨Ù„ Ø£ÙŠ route).

// =============== Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===============
const express = require("express");
const bodyParser = require("body-parser");
const session = require("express-session");
const cors = require("cors");
const morgan = require("morgan");
const dotenv = require("dotenv");
const { execQuery, execQueryOne, withTransaction } = require("./db");
dotenv.config();

// ================= Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³ÙŠØ±ÙØ± =================
const app = express();
app.use(express.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors({ origin: true, credentials: true }));
app.use(morgan("dev"));
app.use(express.static("public"));

// ================= Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø© =================
app.use(
  session({
    secret: process.env.SESSION_SECRET || "ehgzly_secret",
    resave: false,
    saveUninitialized: false,
    cookie: { secure: false },
  })
);

// Ø¯Ø§Ù„Ø© ÙˆØ³ÙŠØ·Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ù„Ø³Ø©
function requireLogin(req, res, next) {
  if (!req.session.user) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}

// Ø¯Ø§Ù„Ø© ÙˆØ³ÙŠØ·Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¯ÙˆØ±
function requireRole(role) {
  return (req, res, next) => {
    if (!req.session.user || req.session.user.role !== role) {
      return res.status(403).json({ message: "Forbidden" });
    }
    next();
  };
}

ðŸŸ© Ø«Ø§Ù†ÙŠÙ‹Ø§: Endpoint Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ

ÙŠØ³ØªØ®Ø¯ÙŽÙ… ÙÙŠ admin.js Ùˆ owner.js Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….

app.get("/api/me", requireLogin, async (req, res) => {
  try {
    const user = req.session.user;
    res.json(user);
  } catch (e) {
    res.status(500).json({ message: "Server Error" });
  }
});

ðŸŸ§ Ø«Ø§Ù„Ø«Ù‹Ø§: Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø¯Ù…Ù† (/api/admin/...)

Ø¯ÙŠ ÙƒÙ„Ù‡Ø§ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ù…Ù† Ø§Ù„ÙƒØ§Ù…Ù„Ø© ÙÙ‚Ø·.

// ðŸ§  Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
app.get("/api/admin/dashboard", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const [users, stadiums, bookings, payments] = await Promise.all([
      execQueryOne("SELECT COUNT(*) AS total_users FROM users"),
      execQueryOne("SELECT COUNT(*) AS total_stadiums FROM stadiums"),
      execQueryOne("SELECT COUNT(*) AS total_bookings FROM bookings"),
      execQueryOne("SELECT COALESCE(SUM(amount), 0) AS total_revenue FROM payments WHERE status = 'confirmed'")
    ]);
    res.json({
      totalUsers: users.total_users,
      totalStadiums: stadiums.total_stadiums,
      totalBookings: bookings.total_bookings,
      totalRevenue: payments.total_revenue
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Error loading dashboard data" });
  }
});

// ðŸŸï¸ Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨
app.get("/api/admin/stadiums", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const data = await execQuery("SELECT id, name, location, area, price, is_active FROM stadiums ORDER BY id DESC");
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading stadiums" });
  }
});

// ðŸ‘¥ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
app.get("/api/admin/users", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const data = await execQuery("SELECT id, username, email, phone, role, approved FROM users ORDER BY created_at DESC");
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading users" });
  }
});

// ðŸ§¾ Ø¹Ø±Ø¶ Ø¢Ø®Ø± Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª
app.get("/api/admin/bookings", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const data = await execQuery(`
      SELECT customer_name, pitch_name, date, time, amount, status
      FROM bookings
      ORDER BY created_at DESC
      LIMIT $1
    `, [limit]);
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading bookings" });
  }
});

// ðŸ§‘â€ðŸ’¼ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¯ÙŠØ±ÙŠÙ† Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
app.get("/api/admin/pending-managers", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const data = await execQuery(`
      SELECT u.id AS user_id, u.username, u.email, json_agg(s.name) AS requested_stadiums
      FROM stadium_managers sm
      JOIN users u ON sm.user_id = u.id
      JOIN stadiums s ON sm.stadium_id = s.id
      WHERE sm.is_active = false
      GROUP BY u.id, u.username, u.email
    `);
    res.json(data);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Error loading pending managers" });
  }
});

// âœ… Ù‚Ø¨ÙˆÙ„ Ù…Ø¯ÙŠØ±
app.post("/api/admin/pending-managers/:id/approve", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    await execQuery("UPDATE stadium_managers SET is_active = true WHERE user_id = $1", [req.params.id]);
    res.json({ message: "Manager approved" });
  } catch (err) {
    res.status(500).json({ message: "Error approving manager" });
  }
});

// âŒ Ø±ÙØ¶ Ù…Ø¯ÙŠØ±
app.post("/api/admin/pending-managers/:id/reject", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    await execQuery("DELETE FROM stadium_managers WHERE user_id = $1", [req.params.id]);
    res.json({ message: "Manager rejected" });
  } catch (err) {
    res.status(500).json({ message: "Error rejecting manager" });
  }
});

// ðŸ“œ Ø³Ø¬Ù„ Ø§Ù„Ù†Ø´Ø§Ø·
app.get("/api/admin/activity-logs", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 15;
    const logs = await execQuery(`
      SELECT a.*, u.username AS user_name
      FROM activity_logs a
      LEFT JOIN users u ON a.user_id = u.id
      ORDER BY a.created_at DESC
      LIMIT $1
    `, [limit]);
    res.json(logs);
  } catch (err) {
    res.status(500).json({ message: "Error loading logs" });
  }
});

ðŸŸ¦ Ø±Ø§Ø¨Ø¹Ù‹Ø§: Ù…Ø³Ø§Ø±Ø§Øª ØµØ§Ø­Ø¨ Ø§Ù„Ù…Ù„Ø¹Ø¨ (/api/owner/...)
// âš½ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
app.get("/api/owner/stadiums", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    const userId = req.session.user.id;
    const stadiums = await execQuery(`
      SELECT s.id, s.name, s.location
      FROM stadiums s
      JOIN stadium_managers sm ON sm.stadium_id = s.id
      WHERE sm.user_id = $1 AND sm.is_active = true
    `, [userId]);
    res.json(stadiums);
  } catch (err) {
    res.status(500).json({ message: "Error loading owner stadiums" });
  }
});

// â±ï¸ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø§Ø¹Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù…Ù„Ø¹Ø¨ Ù…Ø¹ÙŠÙ†
app.get("/api/owner/time-slots/:stadiumId", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    const { stadiumId } = req.params;
    const slots = await execQuery(`
      SELECT id, date, start_time, end_time, price, status
      FROM time_slots
      WHERE stadium_id = $1
      ORDER BY date, start_time
    `, [stadiumId]);
    res.json(slots);
  } catch (err) {
    res.status(500).json({ message: "Error loading time slots" });
  }
});

// ðŸ“‹ ÙƒÙ„ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨ØµØ§Ø­Ø¨ Ø§Ù„Ù…Ù„Ø¹Ø¨
app.get("/api/owner/bookings", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    const userId = req.session.user.id;
    const data = await execQuery(`
      SELECT b.id, b.customer_name, b.pitch_name, b.date, b.time, b.status, b.deposit_amount
      FROM bookings b
      JOIN stadium_managers sm ON sm.stadium_id = b.pitch_id
      WHERE sm.user_id = $1
      ORDER BY b.date DESC
    `, [userId]);
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading bookings" });
  }
});

// âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø² (Ø¹Ù†Ø¯ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø¹Ø±Ø¨ÙˆÙ†)
app.post("/api/owner/bookings/:id/confirm", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    await execQuery("UPDATE bookings SET status = 'confirmed' WHERE id = $1", [req.params.id]);
    res.json({ message: "Booking confirmed" });
  } catch (err) {
    res.status(500).json({ message: "Error confirming booking" });
  }
});

// âŒ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø²
app.post("/api/owner/bookings/:id/cancel", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    await execQuery(`
      UPDATE bookings 
      SET status = 'cancelled'
      WHERE id = $1
    `, [req.params.id]);
    res.json({ message: "Booking cancelled" });
  } catch (err) {
    res.status(500).json({ message: "Error cancelling booking" });
  }
});

ðŸŸ¨ Ø®Ø§Ù…Ø³Ù‹Ø§: ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙŠØ±ÙØ±

ØªØ£ÙƒØ¯ Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ù„Ù.

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ðŸš€ Server running on port ${PORT}`));

âœ… Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:

Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ Ø£Ø¹Ù„Ø§Ù‡:

Ø§Ù„Ø£Ø¯Ù…Ù† Ù‡ÙŠØ´ÙˆÙ ÙƒÙ„ Ø­Ø§Ø¬Ø© (Ù…Ù„Ø§Ø¹Ø¨ØŒ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†ØŒ Ù…Ø¯ÙÙˆØ¹Ø§ØªØŒ Ø£Ù†Ø´Ø·Ø©...).

ØµØ§Ø­Ø¨ Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù‡ÙŠØ´ÙˆÙ Ù…Ù„Ø§Ø¹Ø¨Ù‡ ÙÙ‚Ø· ÙˆØ­Ø¬ÙˆØ²Ø§ØªÙ‡Ø§ ÙˆØ³Ø§Ø¹Ø§ØªÙ‡Ø§.

ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªÙØ³Ø­Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© PostgreSQL Ù…Ø¨Ø§Ø´Ø±Ø©.

Ù…ÙÙŠØ´ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø«Ø§Ø¨ØªØ©.

ÙÙŠ Ø­Ù…Ø§ÙŠØ© ÙƒØ§Ù…Ù„Ø© Ø¨Ø§Ù„Ø£Ø¯ÙˆØ§Ø±.

Ø§Ù„Ø³Ø§Ø¹Ø§Øª ÙÙŠÙ‡Ø§ 3 Ø­Ø§Ù„Ø§Øª ÙÙ‚Ø·:

"available"

"pending" (Ø­Ø¬Ø² ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯)

"confirmed"




1. ÙÙŠ server.js

Ù†Ø¶ÙŠÙ API endpoints Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø¯Ù‡:

ðŸ”¹ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø§Ø¹Ø§Øª:
app.get('/api/stadiums/:id/slots', async (req, res) => {
  const stadiumId = req.params.id;
  const slots = await execQuery(`
    SELECT id, date, start_time, end_time, price, status
    FROM time_slots
    WHERE stadium_id = $1 AND status = 'available'
    ORDER BY date, start_time
  `, [stadiumId]);
  res.json(slots);
});

ðŸ”¹ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¬Ø² Ø¬Ø¯ÙŠØ¯:
app.post('/api/bookings', async (req, res) => {
  const { slot_id, name, phone } = req.body;
  await withTransaction(async (client) => {
    await client.query(`UPDATE time_slots SET status = 'pending' WHERE id = $1`, [slot_id]);
    await client.query(`
      INSERT INTO bookings (pitch_id, customer_name, customer_phone, status, amount)
      VALUES (
        (SELECT stadium_id FROM time_slots WHERE id = $1),
        $2, $3, 'pending', 
        (SELECT price FROM time_slots WHERE id = $1)
      )
    `, [slot_id, name, phone]);
  });
  res.json({ message: "Booking created and pending payment" });
});

ðŸ”¹ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹:
app.post('/api/bookings/:id/confirm', async (req, res) => {
  await withTransaction(async (client) => {
    await client.query(`UPDATE bookings SET status = 'confirmed' WHERE id = $1`, [req.params.id]);
    await client.query(`
      UPDATE time_slots SET status = 'confirmed' 
      WHERE id = (SELECT pitch_id FROM bookings WHERE id = $1)
    `, [req.params.id]);
  });
  res.json({ message: "Booking confirmed" });
});

ðŸ”¹ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø²:
app.post('/api/bookings/:id/cancel', async (req, res) => {
  const { reason } = req.body;
  await withTransaction(async (client) => {
    const booking = await client.query(`SELECT * FROM bookings WHERE id = $1`, [req.params.id]);
    await client.query(`
      INSERT INTO cancelled_bookings (booking_id, customer_name, customer_phone, reason, cancelled_at)
      VALUES ($1, $2, $3, $4, NOW())
    `, [booking.rows[0].id, booking.rows[0].customer_name, booking.rows[0].customer_phone, reason]);
    await client.query(`UPDATE time_slots SET status = 'available' WHERE id = $1`, [booking.rows[0].pitch_id]);
  });
  res.json({ message: "Booking cancelled" });
});
// ---------- Booking system endpoints & helpers ----------
// Assumes: execQuery, execQueryOne, withTransaction imported from db.js
// and requireLogin middleware present (checks req.session.user)

const RESERVATION_TIMEOUT_MINUTES = parseInt(process.env.RESERVATION_TIMEOUT_MINUTES) || 15; // Ù…Ø¯Ø© Ø¨Ù‚Ø§Ø¡ pending Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ

// Utility: get booking details
async function getBookingById(bookingId) {
  return await execQueryOne('SELECT * FROM bookings WHERE id = $1', [bookingId]);
}

// GET slots for a stadium (all, with status). Optionally filter by date.
app.get('/api/stadiums/:stadiumId/slots', async (req, res) => {
  try {
    const stadiumId = parseInt(req.params.stadiumId);
    if (!stadiumId) return res.status(400).json({ error: 'Invalid stadium id' });

    // optional date filter: ?date=2025-11-20
    const date = req.query.date;
    let sql = `SELECT id, stadium_id, date, start_time, end_time, price, status FROM time_slots WHERE stadium_id = $1`;
    const params = [stadiumId];
    if (date) {
      params.push(date);
      sql += ` AND date = $${params.length}`;
    }
    sql += ` ORDER BY date, start_time`;
    const slots = await execQuery(sql, params);
    return res.json(slots);
  } catch (err) {
    console.error('GET /api/stadiums/:stadiumId/slots', err);
    return res.status(500).json({ error: 'Server error' });
  }
});

/**
 * Create booking (atomic)
 * Body: { time_slot_id, customer_name, customer_phone, customer_email, deposit_amount (optional) }
 * Response: { success, bookingId, requiresPayment (true/false), paymentUrl (if provided) }
 *
 * Behavior:
 * - Acquire row lock on time_slots (SELECT ... FOR UPDATE) or use UPDATE ... WHERE status='available' RETURNING id
 * - If available, set status -> 'pending' and insert booking with status 'pending'
 * - If deposit_amount > 0 or payment flow required, returns requiresPayment=true and paymentUrl placeholder
 */
app.post('/api/bookings', async (req, res) => {
  const { time_slot_id, customer_name, customer_phone, customer_email, deposit_amount } = req.body;
  if (!time_slot_id || !customer_name || !customer_phone) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  try {
    // Use transaction with SELECT FOR UPDATE to prevent race
    const result = await withTransaction(async (client) => {
      // Lock the slot
      const slotRes = await client.query('SELECT id, stadium_id, price, status FROM time_slots WHERE id = $1 FOR UPDATE', [time_slot_id]);
      if (slotRes.rowCount === 0) throw { status: 404, message: 'Time slot not found' };
      const slot = slotRes.rows[0];
      if (slot.status !== 'available') throw { status: 409, message: 'Time slot not available' };

      // mark slot pending
      await client.query('UPDATE time_slots SET status = $1 WHERE id = $2', ['pending', time_slot_id]);

      // insert booking
      const totalAmount = slot.price;
      const dep = parseFloat(deposit_amount || 0);
      const insertRes = await client.query(`
        INSERT INTO bookings (time_slot_id, stadium_id, customer_name, customer_phone, customer_email, deposit_amount, total_amount, status, created_at, updated_at)
        VALUES ($1,$2,$3,$4,$5,$6,$7,'pending',NOW(),NOW())
        RETURNING id
      `, [time_slot_id, slot.stadium_id, customer_name, customer_phone, customer_email, dep, totalAmount]);

      const bookingId = insertRes.rows[0].id;

      // If deposit required immediately (business decision): here we return requiresPayment=true so frontend redirects to external payment
      const requiresPayment = dep > 0;

      // Optionally: create a payment session here and return paymentUrl
      // For now we return placeholder; integrate with your payment page: send bookingId to your payment page.
      const paymentUrl = requiresPayment ? `${process.env.PAYMENT_PAGE_URL || '/pay'}?bookingId=${bookingId}` : null;

      return { bookingId, requiresPayment, paymentUrl };
    });

    return res.json({ success: true, bookingId: result.bookingId, requiresPayment: result.requiresPayment, paymentUrl: result.paymentUrl });
  } catch (err) {
    console.error('POST /api/bookings', err);
    if (err && err.status) return res.status(err.status).json({ error: err.message });
    return res.status(500).json({ error: 'Server error' });
  }
});

/**
 * Confirm booking (called by webhook or owner/admin)
 * Only confirm if booking.status is 'pending'
 */
app.post('/api/bookings/:id/confirm', async (req, res) => {
  const bookingId = req.params.id;
  try {
    await withTransaction(async (client) => {
      const bRes = await client.query('SELECT id, time_slot_id, status FROM bookings WHERE id = $1 FOR UPDATE', [bookingId]);
      if (bRes.rowCount === 0) throw { status: 404, message: 'Booking not found' };
      const booking = bRes.rows[0];
      if (booking.status !== 'pending') throw { status: 400, message: 'Booking not pending' };

      // update booking
      await client.query('UPDATE bookings SET status = $1, updated_at = NOW() WHERE id = $2', ['confirmed', bookingId]);
      // update slot
      await client.query('UPDATE time_slots SET status = $1 WHERE id = $2', ['booked', booking.time_slot_id]);

      // optional: insert activity log
      await client.query(`INSERT INTO activity_logs(user_id, action, description, created_at) VALUES ($1,$2,$3,NOW())`, [
        req.session && req.session.user ? req.session.user.id : null,
        'booking.confirm',
        `Booking ${bookingId} confirmed`
      ]);
    });

    return res.json({ success: true });
  } catch (err) {
    console.error('POST /api/bookings/:id/confirm', err);
    if (err && err.status) return res.status(err.status).json({ error: err.message });
    return res.status(500).json({ error: 'Server error' });
  }
});

/**
 * Cancel booking
 * Body: { reason }
 * Behavior: mark booking cancelled and set time_slot back to available
 */
app.post('/api/bookings/:id/cancel', requireLogin, async (req, res) => {
  const bookingId = req.params.id;
  const { reason } = req.body || {};
  try {
    await withTransaction(async (client) => {
      const bRes = await client.query('SELECT id, time_slot_id, status, customer_name FROM bookings WHERE id = $1 FOR UPDATE', [bookingId]);
      if (bRes.rowCount === 0) throw { status: 404, message: 'Booking not found' };
      const booking = bRes.rows[0];
      if (booking.status === 'cancelled') throw { status: 400, message: 'Booking already cancelled' };

      await client.query('UPDATE bookings SET status=$1, cancelled_reason=$2, cancelled_by=$3, cancelled_at=NOW(), updated_at=NOW() WHERE id=$4', [
        'cancelled',
        reason || null,
        req.session && req.session.user ? req.session.user.id : null,
        bookingId
      ]);

      // free the slot
      await client.query('UPDATE time_slots SET status=$1 WHERE id=$2', ['available', booking.time_slot_id]);

      await client.query(`INSERT INTO activity_logs(user_id, action, description, created_at) VALUES ($1,$2,$3,NOW())`, [
        req.session && req.session.user ? req.session.user.id : null,
        'booking.cancel',
        `Booking ${bookingId} cancelled`
      ]);
    });

    return res.json({ success: true });
  } catch (err) {
    console.error('POST /api/bookings/:id/cancel', err);
    if (err && err.status) return res.status(err.status).json({ error: err.message });
    return res.status(500).json({ error: 'Server error' });
  }
});

/**
 * GET /api/bookings?time_slot_id=...  (helper for owner UI)
 */
app.get('/api/bookings', requireLogin, async (req, res) => {
  try {
    const { time_slot_id } = req.query;
    if (time_slot_id) {
      const rows = await execQuery('SELECT * FROM bookings WHERE time_slot_id = $1 ORDER BY created_at DESC', [parseInt(time_slot_id)]);
      return res.json(rows);
    }
    // fallback: if admin return all, if owner return own bookings
    if (req.session && req.session.user) {
      if (req.session.user.role === 'admin') {
        const rows = await execQuery('SELECT * FROM bookings ORDER BY created_at DESC LIMIT 200');
        return res.json(rows);
      } else if (req.session.user.role === 'owner') {
        const stadiumRows = await execQuery('SELECT stadium_id FROM stadium_managers WHERE user_id = $1 AND is_active = TRUE', [req.session.user.id]);
        const ids = stadiumRows.map(r => r.stadium_id);
        if (ids.length === 0) return res.json([]);
        const rows = await execQuery('SELECT * FROM bookings WHERE stadium_id = ANY($1::int[]) ORDER BY created_at DESC', [ids]);
        return res.json(rows);
      } else {
        return res.status(403).json({ error: 'Forbidden' });
      }
    } else {
      return res.status(401).json({ error: 'Unauthorized' });
    }
  } catch (err) {
    console.error('GET /api/bookings', err);
    return res.status(500).json({ error: 'Server error' });
  }
});
