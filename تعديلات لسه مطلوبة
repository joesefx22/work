Ø£ÙˆÙ„Ø§Ù‹: Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© Ø§Ù„Ø¹Ø§Ù…Ø© ÙÙŠ Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù

Ø¶Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ø¨Ø¹Ø¯ require('express') Ù…Ø¨Ø§Ø´Ø±Ø© (Ù‚Ø¨Ù„ Ø£ÙŠ route).

// =============== Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===============
const express = require("express");
const bodyParser = require("body-parser");
const session = require("express-session");
const cors = require("cors");
const morgan = require("morgan");
const dotenv = require("dotenv");
const { execQuery, execQueryOne, withTransaction } = require("./db");
dotenv.config();

// ================= Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³ÙŠØ±ÙØ± =================
const app = express();
app.use(express.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors({ origin: true, credentials: true }));
app.use(morgan("dev"));
app.use(express.static("public"));

// ================= Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø© =================
app.use(
  session({
    secret: process.env.SESSION_SECRET || "ehgzly_secret",
    resave: false,
    saveUninitialized: false,
    cookie: { secure: false },
  })
);

// Ø¯Ø§Ù„Ø© ÙˆØ³ÙŠØ·Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ù„Ø³Ø©
function requireLogin(req, res, next) {
  if (!req.session.user) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}

// Ø¯Ø§Ù„Ø© ÙˆØ³ÙŠØ·Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¯ÙˆØ±
function requireRole(role) {
  return (req, res, next) => {
    if (!req.session.user || req.session.user.role !== role) {
      return res.status(403).json({ message: "Forbidden" });
    }
    next();
  };
}

ðŸŸ© Ø«Ø§Ù†ÙŠÙ‹Ø§: Endpoint Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ

ÙŠØ³ØªØ®Ø¯ÙŽÙ… ÙÙŠ admin.js Ùˆ owner.js Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….

app.get("/api/me", requireLogin, async (req, res) => {
  try {
    const user = req.session.user;
    res.json(user);
  } catch (e) {
    res.status(500).json({ message: "Server Error" });
  }
});

ðŸŸ§ Ø«Ø§Ù„Ø«Ù‹Ø§: Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø¯Ù…Ù† (/api/admin/...)

Ø¯ÙŠ ÙƒÙ„Ù‡Ø§ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ù…Ù† Ø§Ù„ÙƒØ§Ù…Ù„Ø© ÙÙ‚Ø·.

// ðŸ§  Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
app.get("/api/admin/dashboard", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const [users, stadiums, bookings, payments] = await Promise.all([
      execQueryOne("SELECT COUNT(*) AS total_users FROM users"),
      execQueryOne("SELECT COUNT(*) AS total_stadiums FROM stadiums"),
      execQueryOne("SELECT COUNT(*) AS total_bookings FROM bookings"),
      execQueryOne("SELECT COALESCE(SUM(amount), 0) AS total_revenue FROM payments WHERE status = 'confirmed'")
    ]);
    res.json({
      totalUsers: users.total_users,
      totalStadiums: stadiums.total_stadiums,
      totalBookings: bookings.total_bookings,
      totalRevenue: payments.total_revenue
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Error loading dashboard data" });
  }
});

// ðŸŸï¸ Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨
app.get("/api/admin/stadiums", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const data = await execQuery("SELECT id, name, location, area, price, is_active FROM stadiums ORDER BY id DESC");
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading stadiums" });
  }
});

// ðŸ‘¥ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
app.get("/api/admin/users", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const data = await execQuery("SELECT id, username, email, phone, role, approved FROM users ORDER BY created_at DESC");
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading users" });
  }
});

// ðŸ§¾ Ø¹Ø±Ø¶ Ø¢Ø®Ø± Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª
app.get("/api/admin/bookings", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const data = await execQuery(`
      SELECT customer_name, pitch_name, date, time, amount, status
      FROM bookings
      ORDER BY created_at DESC
      LIMIT $1
    `, [limit]);
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading bookings" });
  }
});

// ðŸ§‘â€ðŸ’¼ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¯ÙŠØ±ÙŠÙ† Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
app.get("/api/admin/pending-managers", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const data = await execQuery(`
      SELECT u.id AS user_id, u.username, u.email, json_agg(s.name) AS requested_stadiums
      FROM stadium_managers sm
      JOIN users u ON sm.user_id = u.id
      JOIN stadiums s ON sm.stadium_id = s.id
      WHERE sm.is_active = false
      GROUP BY u.id, u.username, u.email
    `);
    res.json(data);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Error loading pending managers" });
  }
});

// âœ… Ù‚Ø¨ÙˆÙ„ Ù…Ø¯ÙŠØ±
app.post("/api/admin/pending-managers/:id/approve", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    await execQuery("UPDATE stadium_managers SET is_active = true WHERE user_id = $1", [req.params.id]);
    res.json({ message: "Manager approved" });
  } catch (err) {
    res.status(500).json({ message: "Error approving manager" });
  }
});

// âŒ Ø±ÙØ¶ Ù…Ø¯ÙŠØ±
app.post("/api/admin/pending-managers/:id/reject", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    await execQuery("DELETE FROM stadium_managers WHERE user_id = $1", [req.params.id]);
    res.json({ message: "Manager rejected" });
  } catch (err) {
    res.status(500).json({ message: "Error rejecting manager" });
  }
});

// ðŸ“œ Ø³Ø¬Ù„ Ø§Ù„Ù†Ø´Ø§Ø·
app.get("/api/admin/activity-logs", requireLogin, requireRole("admin"), async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 15;
    const logs = await execQuery(`
      SELECT a.*, u.username AS user_name
      FROM activity_logs a
      LEFT JOIN users u ON a.user_id = u.id
      ORDER BY a.created_at DESC
      LIMIT $1
    `, [limit]);
    res.json(logs);
  } catch (err) {
    res.status(500).json({ message: "Error loading logs" });
  }
});

ðŸŸ¦ Ø±Ø§Ø¨Ø¹Ù‹Ø§: Ù…Ø³Ø§Ø±Ø§Øª ØµØ§Ø­Ø¨ Ø§Ù„Ù…Ù„Ø¹Ø¨ (/api/owner/...)
// âš½ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
app.get("/api/owner/stadiums", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    const userId = req.session.user.id;
    const stadiums = await execQuery(`
      SELECT s.id, s.name, s.location
      FROM stadiums s
      JOIN stadium_managers sm ON sm.stadium_id = s.id
      WHERE sm.user_id = $1 AND sm.is_active = true
    `, [userId]);
    res.json(stadiums);
  } catch (err) {
    res.status(500).json({ message: "Error loading owner stadiums" });
  }
});

// â±ï¸ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø§Ø¹Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù…Ù„Ø¹Ø¨ Ù…Ø¹ÙŠÙ†
app.get("/api/owner/time-slots/:stadiumId", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    const { stadiumId } = req.params;
    const slots = await execQuery(`
      SELECT id, date, start_time, end_time, price, status
      FROM time_slots
      WHERE stadium_id = $1
      ORDER BY date, start_time
    `, [stadiumId]);
    res.json(slots);
  } catch (err) {
    res.status(500).json({ message: "Error loading time slots" });
  }
});

// ðŸ“‹ ÙƒÙ„ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨ØµØ§Ø­Ø¨ Ø§Ù„Ù…Ù„Ø¹Ø¨
app.get("/api/owner/bookings", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    const userId = req.session.user.id;
    const data = await execQuery(`
      SELECT b.id, b.customer_name, b.pitch_name, b.date, b.time, b.status, b.deposit_amount
      FROM bookings b
      JOIN stadium_managers sm ON sm.stadium_id = b.pitch_id
      WHERE sm.user_id = $1
      ORDER BY b.date DESC
    `, [userId]);
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Error loading bookings" });
  }
});

// âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø² (Ø¹Ù†Ø¯ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø¹Ø±Ø¨ÙˆÙ†)
app.post("/api/owner/bookings/:id/confirm", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    await execQuery("UPDATE bookings SET status = 'confirmed' WHERE id = $1", [req.params.id]);
    res.json({ message: "Booking confirmed" });
  } catch (err) {
    res.status(500).json({ message: "Error confirming booking" });
  }
});

// âŒ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø²
app.post("/api/owner/bookings/:id/cancel", requireLogin, requireRole("owner"), async (req, res) => {
  try {
    await execQuery(`
      UPDATE bookings 
      SET status = 'cancelled'
      WHERE id = $1
    `, [req.params.id]);
    res.json({ message: "Booking cancelled" });
  } catch (err) {
    res.status(500).json({ message: "Error cancelling booking" });
  }
});

ðŸŸ¨ Ø®Ø§Ù…Ø³Ù‹Ø§: ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙŠØ±ÙØ±

ØªØ£ÙƒØ¯ Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ù„Ù.

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ðŸš€ Server running on port ${PORT}`));

âœ… Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:

Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ Ø£Ø¹Ù„Ø§Ù‡:

Ø§Ù„Ø£Ø¯Ù…Ù† Ù‡ÙŠØ´ÙˆÙ ÙƒÙ„ Ø­Ø§Ø¬Ø© (Ù…Ù„Ø§Ø¹Ø¨ØŒ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†ØŒ Ù…Ø¯ÙÙˆØ¹Ø§ØªØŒ Ø£Ù†Ø´Ø·Ø©...).

ØµØ§Ø­Ø¨ Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù‡ÙŠØ´ÙˆÙ Ù…Ù„Ø§Ø¹Ø¨Ù‡ ÙÙ‚Ø· ÙˆØ­Ø¬ÙˆØ²Ø§ØªÙ‡Ø§ ÙˆØ³Ø§Ø¹Ø§ØªÙ‡Ø§.

ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªÙØ³Ø­Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© PostgreSQL Ù…Ø¨Ø§Ø´Ø±Ø©.

Ù…ÙÙŠØ´ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø«Ø§Ø¨ØªØ©.

ÙÙŠ Ø­Ù…Ø§ÙŠØ© ÙƒØ§Ù…Ù„Ø© Ø¨Ø§Ù„Ø£Ø¯ÙˆØ§Ø±.

Ø§Ù„Ø³Ø§Ø¹Ø§Øª ÙÙŠÙ‡Ø§ 3 Ø­Ø§Ù„Ø§Øª ÙÙ‚Ø·:

"available"

"pending" (Ø­Ø¬Ø² ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯)

"confirmed"




1. ÙÙŠ server.js

Ù†Ø¶ÙŠÙ API endpoints Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø¯Ù‡:

ðŸ”¹ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø§Ø¹Ø§Øª:
app.get('/api/stadiums/:id/slots', async (req, res) => {
  const stadiumId = req.params.id;
  const slots = await execQuery(`
    SELECT id, date, start_time, end_time, price, status
    FROM time_slots
    WHERE stadium_id = $1 AND status = 'available'
    ORDER BY date, start_time
  `, [stadiumId]);
  res.json(slots);
});

ðŸ”¹ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¬Ø² Ø¬Ø¯ÙŠØ¯:
app.post('/api/bookings', async (req, res) => {
  const { slot_id, name, phone } = req.body;
  await withTransaction(async (client) => {
    await client.query(`UPDATE time_slots SET status = 'pending' WHERE id = $1`, [slot_id]);
    await client.query(`
      INSERT INTO bookings (pitch_id, customer_name, customer_phone, status, amount)
      VALUES (
        (SELECT stadium_id FROM time_slots WHERE id = $1),
        $2, $3, 'pending', 
        (SELECT price FROM time_slots WHERE id = $1)
      )
    `, [slot_id, name, phone]);
  });
  res.json({ message: "Booking created and pending payment" });
});

ðŸ”¹ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹:
app.post('/api/bookings/:id/confirm', async (req, res) => {
  await withTransaction(async (client) => {
    await client.query(`UPDATE bookings SET status = 'confirmed' WHERE id = $1`, [req.params.id]);
    await client.query(`
      UPDATE time_slots SET status = 'confirmed' 
      WHERE id = (SELECT pitch_id FROM bookings WHERE id = $1)
    `, [req.params.id]);
  });
  res.json({ message: "Booking confirmed" });
});

ðŸ”¹ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø²:
app.post('/api/bookings/:id/cancel', async (req, res) => {
  const { reason } = req.body;
  await withTransaction(async (client) => {
    const booking = await client.query(`SELECT * FROM bookings WHERE id = $1`, [req.params.id]);
    await client.query(`
      INSERT INTO cancelled_bookings (booking_id, customer_name, customer_phone, reason, cancelled_at)
      VALUES ($1, $2, $3, $4, NOW())
    `, [booking.rows[0].id, booking.rows[0].customer_name, booking.rows[0].customer_phone, reason]);
    await client.query(`UPDATE time_slots SET status = 'available' WHERE id = $1`, [booking.rows[0].pitch_id]);
  });
  res.json({ message: "Booking cancelled" });
});
